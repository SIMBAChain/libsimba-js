<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/simba/simba.js | libsimba-js</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Simbachain Blockchain abstraction and interaction library"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="libsimba-js"><meta property="twitter:description" content="Simbachain Blockchain abstraction and interaction library"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/simbachain/libsimba-js"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/exceptions.js~BadMetadataException.html">BadMetadataException</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/exceptions.js~BaseException.html">BaseException</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/exceptions.js~GenerateTransactionException.html">GenerateTransactionException</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/exceptions.js~GetRequestException.html">GetRequestException</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/exceptions.js~GetTransactionsException.html">GetTransactionsException</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/exceptions.js~MethodCallValidationMetadataException.html">MethodCallValidationMetadataException</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/exceptions.js~MissingMetadataException.html">MissingMetadataException</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/exceptions.js~NotImplementedException.html">NotImplementedException</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/exceptions.js~NotInBrowserException.html">NotInBrowserException</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/exceptions.js~PostRequestException.html">PostRequestException</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/exceptions.js~RetriesExceededException.html">RetriesExceededException</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/exceptions.js~SigningException.html">SigningException</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/exceptions.js~SubmitTransactionException.html">SubmitTransactionException</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/exceptions.js~TransactionStatusCheckException.html">TransactionStatusCheckException</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/exceptions.js~UserRejectedSigningException.html">UserRejectedSigningException</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/exceptions.js~WalletLockedException.html">WalletLockedException</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/exceptions.js~WalletNotFoundException.html">WalletNotFoundException</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getSimbaInstance">getSimbaInstance</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#simba">simba</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/simba/pagedresponse.js~PagedResponse.html">PagedResponse</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/simba/simba.js~Simbachain.html">Simbachain</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/simba/simbabase.js~SimbaBase.html">SimbaBase</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#wallet">wallet</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/wallet/localwallet.js~LocalWallet.html">LocalWallet</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/wallet/pkwallet.js~PKWallet.html">PKWallet</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/wallet/wallet.js~Wallet.html">Wallet</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/simba/simba.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import SimbaBase from &apos;./simbabase&apos;;
import {
    WalletNotFoundException,
    MissingMetadataException,
    GenerateTransactionException,
    SubmitTransactionException,
    TransactionStatusCheckException,
    NotImplementedException,
    GetTransactionsException,
    GetRequestException,
    PostRequestException,
    RetriesExceededException
} from &apos;../exceptions&apos;;
import PagedResponse from &quot;./pagedresponse&quot;;
import axios from &apos;axios&apos;;

if (typeof XMLHttpRequest !== &apos;undefined&apos;) {
    // For browsers use XHR adapter
    axios.defaults.adapter = require(&apos;axios/lib/adapters/xhr&apos;);
} else if (typeof process !== &apos;undefined&apos;) {
    // For node use HTTP adapter
    axios.defaults.adapter = require(&apos;axios/lib/adapters/http&apos;);
}

const request = axios.request;

/**
 * libsimba API Interaction for Simbachain.com
 */
export default class Simbachain extends SimbaBase {
    /**
     * libsimba API Interaction for Simbachain.com
     * @param {string} endpoint - The endpoint of the API
     * @param {Wallet} [wallet] - an optional {@link Wallet} instance
     */
    constructor(endpoint, wallet) {
        super(endpoint, wallet);
    }

    /**
     * @private
     * Perform asynchronous actions needed to initialise this class
     */
    async initialize() {
        let response = await request({
            url: `${this.endpoint}?format=openapi`,
            responseType: &apos;json&apos;
        });
        let swagger = response.data;

        if (&apos;info&apos; in swagger &amp;&amp; &apos;x-simba-attrs&apos; in swagger.info) {
            this.metadata = swagger.info[&apos;x-simba-attrs&apos;];
        }
    }

    /**
     * @override
     * Call a method on the API
     * @param {string} method - the method to call
     * @param {Object} parameters - the parameters for the method
     * @return {Promise} - a promise resolving with the transaction details
     */
    async callMethod(method, parameters) {
        if (!this.wallet) {
            throw new WalletNotFoundException(&quot;No Wallet found&quot;);
        }

        this.validateCall(method, parameters);

        let formData = new FormData();
        let address = await this.wallet.getAddress();
        formData.append(&apos;from&apos;, address);
        for (let [key, value] of Object.entries(parameters)) {
            formData.append(key, value);
        }

        return this.sendMethodRequest(method, formData);
    }

    /**
     * @override
     * Get the status of a transaction by ID
     * @param {string} txnId - the transaction ID
     * @return {Promise&lt;Object&gt;} - a promise resolving with the transaction details
     */
    getTransactionStatus(txnId) {
        return request({
            url: `${this.endpoint}transaction/${txnId}/`,
            method: &apos;GET&apos;,
            headers: this.apiAuthHeaders(),
            responseType: &apos;json&apos;
        })
            .then(async (response) =&gt; {
                return response.data;
            })
            .catch(error=&gt;{
                throw new TransactionStatusCheckException(JSON.stringify(error.response.data));
            });
    }

    /**
     * @override
     * @private
     * Gets the status of a transaction
     * @param {Object} txn - a transaction object
     * @return {Object} - an object with status details
     */
    checkTransactionStatusFromObject(txn) {
        let ret = {
            status: &apos;&apos;,
            transaction_hash: &apos;&apos;
        };

        if (txn.transaction_hash) {
            ret.transaction_hash = txn.transaction_hash;
        }

        if (txn.error) {
            ret.status = &apos;error&apos;;
            ret.error = txn.error;
            ret.error_details = txn.error_details;
        } else if (!txn.receipt) {
            ret.status = &apos;pending&apos;;
        } else {
            ret.status = &apos;success&apos;;
        }

        return ret;
    }

    /**
     * @override
     * @private
     * Check if the transaction is complete
     * @param {Object} txn - the transaction object
     * @return {boolean} - is the transaction complete
     */
    checkTransactionDone(txn) {
        return txn.status !== &apos;pending&apos;;
    }

    /**
     * @override
     * @private
     * Gets the status of a transaction by ID
     * @param {string} txnId - a transaction ID
     * @return {Object} - an object with status details
     */
    checkTransactionStatus(txnId) {
        return this.getTransactionStatus(txnId)
            .then(this.checkTransactionStatusFromObject);
    }

    /**
     * @override
     * Get the balance for the attached Wallet
     * @return {Promise&lt;Object&gt;} - the balance
     */
    async getBalance() {
        if (!this.metadata) {
            throw new MissingMetadataException(&quot;App Metadata not yet retrieved&quot;);
        }

        if (!this.wallet) {
            throw new WalletNotFoundException(&quot;No Wallet found&quot;);
        }

        if (this.metadata.poa) {
            return Promise.resolve({
                amount: -1,
                currency: &quot;&quot;,
                poa: true
            });
        }

        let address = await this.wallet.getAddress();
        let response = await request(
            {
                url: `${this.endpoint}balance/${address}/`,
                method: &apos;GET&apos;,
                headers: Object.assign({&apos;Content-Type&apos;:&apos;application/json&apos;},this.apiAuthHeaders()),
                responseType: &apos;json&apos;
            }
        ).catch(error=&gt;{
                throw new GetRequestException(JSON.stringify(error.response.data));
            });

        return Promise.resolve({
            ...response.data,
            poa: false
        });
    }

    /**
     * @override
     * Add funds to the attached Wallet.
     * Please check the output of this method. It is of the form
     * ```
     * {
     *     txnId: null,
     *     faucet_url: null,
     *     poa: true
     * }
     * ```
     *
     * If successful, txnId will be populated.
     * If the network is PoA, then poa will be true, and txnId will be null
     * If the faucet for the network is external (e.g. Rinkeby, Ropsten, etc), then txnId will be null,
     * and faucet_url will be populated with a URL. You should present this URL to your users to direct them
     * to request funds there.
     * @return {Promise&lt;Object&gt;} - details of the txn
     */
    async addFunds() {
        if (!this.metadata) {
            throw new MissingMetadataException(&quot;App Metadata not yet retrieved&quot;);
        }

        if (!this.wallet) {
            throw new WalletNotFoundException(&quot;No Wallet found&quot;);
        }

        let address = await this.wallet.getAddress();

        if (this.metadata.poa) {
            return Promise.resolve({
                txnId: null,
                poa: true,
                faucet_url: null
            });
        }

        if (!this.metadata.simba_faucet) {
            return Promise.resolve({
                txnId: null,
                poa: false,
                faucet_url: this.metadata.faucet
            });
        }

        let requestData = {
            account: address,
            value: &quot;1&quot;,
            currency: &quot;ether&quot;
        };

        let response = await request(
            {
                url: `${this.endpoint}balance/${address}/`,
                method: &apos;POST&apos;,
                headers: Object.assign({&apos;Content-Type&apos;:&apos;application/json&apos;}, this.apiAuthHeaders()),
                data: requestData,
                responseType: &apos;json&apos;
            }
        ).catch(error=&gt;{
            throw new PostRequestException(JSON.stringify(error.response.data));
        });


        return Promise.resolve({
            ...response.data,
            poa: false,
            faucet_url: null
        });
    }

    /**
     * @override
     * Call a method on the API with files
     * @param {string} method - the method to call
     * @param {Object} parameters- the parameters for the method
     * @param {Array&lt;Blob|File&gt;} files - the files
     * @return {Promise&lt;Object&gt;} - a promise resolving with the transaction details
     */
    async callMethodWithFile(method, parameters, files) {
        if (!this.wallet) {
            throw new WalletNotFoundException(&quot;No Wallet found&quot;);
        }

        this.validateCall(method, parameters, files);

        let formData = new FormData();
        let address = await this.wallet.getAddress();
        formData.append(&apos;from&apos;, address);
        for (let [key, value] of Object.entries(parameters)) {
            formData.append(key, value);
        }

        for(let i = 0; i &lt; files.length; i++){
            formData.append(`file[${i}]`, files[i]);
        }

        return this.sendMethodRequest(method, formData);
    }

    /**
     * @private
     * Internal method for submitting method calls and retrying on nonce errors
     * @param {string} txnId - the txnId
     * @param {string} signed - The signed txn
     * @returns {Promise&lt;Response&gt;} - The response with transaction data
     */
    async submitTxn(txnId, payload, maxTries, currentTry){
        if(!maxTries) maxTries = 5;
        if(!currentTry) currentTry = 0;
        if(currentTry &gt; maxTries){
            throw new RetriesExceededException();
        }
        // tslint:disable-next-line: no-unsafe-any
        const signed = await this.wallet.sign(payload);

        return request({
            url: `${this.endpoint}transaction/${txnId}/`,
            method: &apos;POST&apos;,
            headers: Object.assign({&apos;Content-Type&apos;:&apos;application/json&apos;},this.apiAuthHeaders()),
            data: {payload: signed},
            responseType: &apos;json&apos;
        }).then(response =&gt; {
            // tslint:disable-next-line: no-console
            console.log(&apos;Success!&apos;, response.data);
            return txnId;
        }).catch(ex=&gt;{
            let body = ex.response.data;
            if(body.errors &amp;&amp; body.errors.length){
                let error = body.errors[0];
                if(error.detail &amp;&amp; error.detail.code){
                    let code = error.detail.code;
                    //Nonce Error
                    if(code === &quot;15001&quot; &amp;&amp; error.detail.meta &amp;&amp; error.detail.meta.suggested_nonce){
                        console.log(&quot;Nonce Too Low, trying again with suggested nonce &quot; + error.detail.meta.suggested_nonce);
                        payload.nonce = error.detail.meta.suggested_nonce;
                        return this.submitTxn(txnId, payload, maxTries, currentTry++);
                    }
                }
            }
            throw new SubmitTransactionException(JSON.stringify(body));
        });
    }

    /**
     * @private
     * Internal method for sending method calls
     * @param {string} url - the url
     * @param {FormData} formdata - Formdata for the POST
     * @returns {Promise&lt;Response&gt;} - The response with transaction data
     */
    async sendMethodRequest(method, formdata){
        let txnId = null;
        let payload;

        return request({
            url: `${this.endpoint}${method}/`,
            method: &apos;POST&apos;,
            headers: this.apiAuthHeaders(),
            data: formdata,
            responseType: &apos;json&apos;
        })
            .then((response) =&gt; {
                // tslint:disable-next-line: no-unsafe-any
                txnId = response.data.id;
                // tslint:disable-next-line: no-unsafe-any

                payload = response.data.payload.raw;

                return this.submitTxn(txnId, payload);
            })
            .catch(ex=&gt;{
                throw new GenerateTransactionException(JSON.stringify(ex.response.data));
            });
    }

    /**
     * @override
     * Gets a specific transaction
     * @param {string} transactionIdOrHash - Either a transaction ID or a transaction hash
     * @returns {Promise&lt;Object&gt;} - The transaction
     */
    async getTransaction(transactionIdOrHash) {
        this.validateAnyGetCall();

        let url = new URL(`${this.endpoint}transaction/${transactionIdOrHash}/`);

        let response = await request({
            url: url,
            method: &apos;GET&apos;,
            headers: this.apiAuthHeaders(),
            responseType: &apos;json&apos;
        })
            .catch(ex=&gt;{
                throw new GetTransactionsException(ex.response.data);
            });

        return response.data;
    }

    /**
     * @override
     * Gets a paged list of transactions
     * @param {Object} parameters - The query parameters
     * @returns {Promise&lt;PagedResponse&gt;} - A response wrapped in a {@link PagedResponse} helper
     */
    async getTransactions(parameters) {
        this.validateAnyGetCall();

        let url = new URL(`${this.endpoint}transaction/`);

        for (let [key, value] of Object.entries(parameters)) {
            url.searchParams.set(key, value);
        }

        return this.sendTransactionRequest(url.toString());
    }

    /**
     * @override
     * Gets a paged list of transactions for the method
     * @param {string} method - The method
     * @param {Object} parameters - The query parameters
     * @returns {Promise&lt;PagedResponse&gt;} - A response wrapped in a {@link PagedResponse} helper
     */
    async getMethodTransactions(method, parameters) {
        this.validateGetCall(method, parameters);

        let url = new URL(`${this.endpoint}${method}/`);

        for (let [key, value] of Object.entries(parameters)) {
            url.searchParams.set(key, value);
        }

        return this.sendTransactionRequest(url.toString());
    }

    /**
     * @protected
     * @override
     * Internal function for sending transaction GET requests
     * @param {URL} url - The URL
     * @returns {Promise&lt;PagedResponse&gt;} - A response wrapped in a {@link PagedResponse} helper
     */
    async sendTransactionRequest(url){
        let response = await request({
            url: url,
            method: &apos;GET&apos;,
            headers: this.apiAuthHeaders(),
            responseType: &apos;json&apos;
        })
            .catch(ex=&gt;{
                throw new GetTransactionsException(ex.response.data);
            });

        return new PagedResponse(response.data, url, this);
    }


    /**
     * @override
     * Gets a the bundle metadata for a transaction
     * @param {string} transactionIdOrHash - Either a transaction ID or a transaction hash
     * @returns {Promise&lt;Object&gt;} - The bundle metadata
     */
    async getBundleMetadataForTransaction(transactionIdOrHash) {
        let url = new URL(`${this.endpoint}transaction/${transactionIdOrHash}/bundle/`);

        url.searchParams.append(&apos;no_files&apos;, true);

        let response = await request({
            url: url,
            method: &apos;GET&apos;,
            headers: this.apiAuthHeaders(),
            json: true
        })
            .catch(ex=&gt;{
                throw new GetRequestException(ex.response.data);
            });

        return response.data;
    }

    /**
     * @override
     * Gets the bundle for a transaction
     * @param {string} transactionIdOrHash - Either a transaction ID or a transaction hash
     * @returns {Promise&lt;ReadableStream|Blob&gt;} - The bundle
     */
    async getBundleForTransaction(transactionIdOrHash) {
        let url = new URL(`${this.endpoint}transaction/${transactionIdOrHash}/bundle_raw/`);

        let responseType = &apos;arraybuffer&apos;;
        if (typeof window !== &apos;undefined&apos;){
            //in a browser
            responseType = &apos;blob&apos;;
        }

        let response = await request({
            url: url,
            method: &apos;GET&apos;,
            headers: this.apiAuthHeaders(),
            responseType: responseType
        })
            .catch(ex=&gt;{
                throw new GetRequestException(ex.response.data);
            });

        return response.data;
    }

    /**
     * @override
     * Gets a file from the bundle for a transaction
     * @param {string} transactionIdOrHash - Either a transaction ID or a transaction hash
     * @param {number} fileIdx - The index of the file in the bundle metadata
     * @param {boolean} stream - If true, returns a {@link ReadableStream}, otherwise returns a {@link Blob}
     * @returns {Promise&lt;ReadableStream|Blob&gt;} - The file
     */
    async getFileFromBundleForTransaction(transactionIdOrHash, fileIdx, stream) {
        let url = new URL(`${this.endpoint}transaction/${transactionIdOrHash}/file/${fileIdx}/`);

        let responseType = &apos;arraybuffer&apos;;
        if (typeof window !== &apos;undefined&apos;){
            //in a browser
            responseType = &apos;blob&apos;;
        }
        if(stream){
            responseType = &apos;stream&apos;;
        }

        let response = await request({
            url: url,
            method: &apos;GET&apos;,
            headers: this.apiAuthHeaders(),
            responseType: responseType
        })
            .catch(ex=&gt;{
                throw new GetRequestException(ex.response.data);
            });

        console.log(response);
        return response.data;
    }

    /**
     * @override
     * Gets a file from the bundle for a transaction
     * @param {string} transactionIdOrHash - Either a transaction ID or a transaction hash
     * @param {string} fileName - The name of the file in the bundle metadata
     * @param {boolean} stream - If true, returns a {@link ReadableStream}, otherwise returns a {@link Blob}
     * @returns {Promise&lt;ReadableStream|Blob&gt;} - The file
     */
    async getFileFromBundleByNameForTransaction(transactionIdOrHash, fileName, stream) {
        let url = new URL(`${this.endpoint}transaction/${transactionIdOrHash}/fileByName/${fileName}/`);

        let responseType = &apos;arraybuffer&apos;;
        if (typeof window !== &apos;undefined&apos;){
            //in a browser
            responseType = &apos;blob&apos;;
        }
        if(stream){
            responseType = &apos;stream&apos;;
        }

        let response = await request({
            url: url,
            method: &apos;GET&apos;,
            headers: this.apiAuthHeaders(),
            responseType: responseType
        })
            .catch(ex=&gt;{
                throw new GetRequestException(ex.response.data);
            });

        console.log(response);
        return response.data;
    }
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
